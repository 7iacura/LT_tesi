\chapter{Codice Sorgente}

In questa sezione sono riportate e commentate alcune parti del codice sorgente citate nel corso della discussione.

\section*{lib folder}
\label{app:lib}

\subsection*{file bio-ensembl-rest-main.rb}

Come illustrato nel corso della discussione, struttura e nomenclatura dei files di cui \texttt{ensembl-rest} si compone seguono da vicino quelle dell'API Ensembl. L'unico file Ruby non direttamente corrispondente ad un gruppo di \emph{endpoints} è \texttt{bio-ensembl-rest-main.rb}, che contiene alcuni metodi utilizzati da tutti i moduli del progetto. Ne riportiamo e commentiamo brevemente alcuni parti.

\begin{verbatim}
def self.connect_db
  $SERVER = URI.parse 'http://beta.rest.ensembl.org'
  $HTTP_CONNECTION = Net::HTTP.new($SERVER.host, $SERVER.port)
end
\end{verbatim}
Il metodo \texttt{connect\_db}, utilizzato per il settaggio della connessione HTTP con il server Ensembl, si compone di due sole righe di codice. La complessità dell'operazione è enormemente ridotta dall'utilizzo del pacchetto \texttt{net/http}, contenuto nella libreria standard Ruby.

Anche il metodo \texttt{fetch\_data} è molto compatto:
\begin{verbatim}
def self.fetch_data(path, opts, mod)
  request = Net::HTTP::Get.new path
  request.content_type = opts['content-type'] || default_types[mod]
  response = $HTTP_CONNECTION.request request
  return check_response response
end
\end{verbatim} 
Nella prima riga la libreria prepara un pacchetto HTTP e metodo GET, che sarà utilizzato per inviare al server la richiesta dell'utente. Il campo Content-type nell'header viene settato in base a quanto passato al metodo dall'utente, oppure ad un valore di default, a seconda della presenza o meno, nella tabella hash contenente i parametri opzionali, di un campo avente chiave \texttt{content-type}. Nella terza riga viene utilizzata la connessione HTTP già settata per l'invio del pacchetto HTTP appena costruito. La quarta riga effettua un controllo sulla risposta (tramite il metodo \texttt{check\_responde}) e restituisce il risultato.

\subsection*{Definizione dinamica della classe Homology}

\begin{verbatim}
def self.build_homology_class(json_data)
  homologies_data = json_data['data'][0]['homologies']

  homology_methods = []
  homologies_data.first.each {|k, _| homology_methods << k.to_sym}
  
  homology_methods.each do
    |k, _| Homology.class_eval "attr_accessor :#{k}"
  end
  Homology.class_eval "attr_accessor :bio_methods"

  homologies = []

  homologies_data.each do |hom| 
    h = Homology.new
    hom.each { |k, v| h.send "#{k}=".to_sym, v }
    h.send :bio_methods=, homology_methods 
    homologies << h 
  end

  return homologies
end
\end{verbatim}

Il codice qui listato è quello responsabile per la definizione \emph{a run-time} della classe \texttt{Homology} e l'istanziazione degli oggetti da essa derivati, come descritto nella sezione~\ref{sec:meta}. È attualmente utilizzato da due metodi del modulo \texttt{ComparativeGenomics} (\texttt{homology\_id} e \texttt{homology\_symbol}), ma la tecnica potrebbe essere applicata ad altri endpoints.

Nella prima parte del metodo viene estratta una lista delle omologie recuperate dal server, a partire da un documento JSON. Il nome dei campi presenti nel documento viene convertito in simbolo, e successivamente (tramite l'utilizzo del metodo \texttt{class\_eval}) la classe viene fornita di un attributo (e corrispondenti \emph{getters} e \emph{setters}) per ognuno dei campi. Infine, il metodo istanzia un array di oggetti \texttt{Homology}, uno per ogni omologia restituita da server, e lo restituisce all'utente.


\section*{Altri files}
\label{app:files}

\subsection*{Rakefile}
\begin{verbatim}
require `rubygems'
require `bundler'
begin
  Bundler.setup(:default, :development)
rescue Bundler::BundlerError => e
  $stderr.puts e.message
  $stderr.puts "Run `bundle install' to install missing gems"
  exit e.status_code
end
require `rake'

require `jeweler'
Jeweler::Tasks.new do |gem|
  gem.name = "bio-ensembl-rest"
  gem.version = `0.1.0'
  gem.homepage = "http://github.com/ALTree/bio-ensembl-rest"
  gem.license = "MIT"
  gem.summary = "Ruby Ensembl REST api"
  gem.description = "A Ruby library for the RESTful Ensembl API."
  gem.email = "alb.donizetti@gmail.com"
  gem.authors = ["Alberto Donizetti"]
  # dependencies defined in Gemfile
end
Jeweler::RubygemsDotOrgTasks.new

require `rake/testtask'
Rake::TestTask.new(:test) do |test|
  test.libs << `test'
  test.test_files = FileList[`test/test-*.rb']
  test.verbose = true
end

task :default => :test

require `rdoc/task'
Rake::RDocTask.new do |rdoc|
  version = File.exist?(`VERSION') ? File.read(`VERSION') : ""

  rdoc.rdoc_dir = `rdoc'
  rdoc.title = "ensembl-rest #{version}"
  rdoc.rdoc_files.include(`README*')
  rdoc.rdoc_files.include(`lib/**/*.rb')
end
\end{verbatim}

Il Rakefile qui riportato, distribuito insieme alla libreria, semplifica l'esecuzione di alcune \emph{task} tipicamente collegate all'uso e lo sviluppo di una gemma ruby. La prima operazione eseguita nel codice è la chiamata a bundler, lo strumento di controllo e gestione dipendenze di Ruby.

La seconda \emph{task} fa invece uso di \texttt{Jeweler} per l'impacchettamento del codice in un file .gem adatto per il caricamento su RubyGems. Si noti la definizione dei parametri della gemma (nome, autore, versione, ecc\ldots).

Gli ultimi due blocchi (test e doc) permettono rispettivamente di eseguire la suite di test di unità distribuita con \texttt{ensembl-rest} e di generare la documentazione HTML a partire dai commenti nel codice (tramite l'\emph{utility} \texttt{rdoc}).


\subsection*{Gemfile}
\begin{verbatim}
source "http://rubygems.org"
# general dependencies
gem "bio", ">= 1.4.3"
gem "libxml-ruby", ">= 2" if RUBY_PLATFORM != `java'

# dependencies to development process
group :development do
  gem "shoulda", ">= 0"
  gem "rdoc", "~> 3.12"
  gem "bundler", "~> 1.3.5"
  gem "jeweler", "~> 1.8.4"
  gem "bio", ">= 1.4.3"
end
\end{verbatim}

Il Gemfile si occupa della definizione delle dipendenze esterne della libreria. I requisiti generali sono rappresentati da due gemme: \texttt{bio} e \texttt{libxml-ruby}. La prima altro non è che il progetto BioRuby, la seconda è una dipendenza di \texttt{bio} utilizzata nel modulo ComparativeGenomics. È da notare come la seconda gemma non sia richiesta nel caso il codice venga eseguito dall'interprete jRuby (con il quale \texttt{libxml-ruby} non funziona correttamente).